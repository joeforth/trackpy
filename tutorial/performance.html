<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Making trackpy fast(er) &mdash; trackpy 0.2.3-236-gad699e2 documentation</title>
    
    <link rel="stylesheet" href="../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootswatch-3.2.0/spacelab/bootstrap.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap-sphinx.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.2.3-236-gad699e2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-3.2.0/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="trackpy 0.2.3-236-gad699e2 documentation" href="../index.html" />
    <link rel="next" title="Obtaining Diagnostic Information from Linking" href="linking-diagnostics.html" />
    <link rel="prev" title="Streaming: Processing Unlimited Frames On-Disk" href="on-disk.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body role="document">

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../index.html">
          trackpy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2.3-236-gad699e2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../tutorial.html">Tutorial</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../introduction.html">Introduction to Trackpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installing Trackpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html#updating-your-installation">Updating Your Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../whatsnew.html">What&#8217;s new in the package</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="walkthrough.html">Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="prediction.html">Prediction: Beyond Simple Random Walks</a></li>
<li class="toctree-l1"><a class="reference internal" href="tracking-3d.html">Feature finding in 3D confocal images</a></li>
<li class="toctree-l1"><a class="reference internal" href="uncertainty.html">Subpixel Accuracy and Uncertainty Estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="subnets.html">Advanced Linking: Subnetworks and <code class="docutils literal"><span class="pre">search_range</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="adaptive-search.html">Adaptive Search: Changing <code class="docutils literal"><span class="pre">search_range</span></code> on the Fly</a></li>
<li class="toctree-l1"><a class="reference internal" href="on-disk.html">Streaming: Processing Unlimited Frames On-Disk</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Making trackpy fast(er)</a></li>
<li class="toctree-l1"><a class="reference internal" href="linking-diagnostics.html">Obtaining Diagnostic Information from Linking</a></li>
<li class="toctree-l1"><a class="reference internal" href="parallel-locate.html">Parallelized Feature Location using IPython Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="custom-feature-detection.html">Custom Feature Detection: Bubble tracking in 2D foams</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">Making trackpy fast(er)</a><ul>
<li><a class="reference internal" href="#general-advice">General advice</a><ul>
<li><a class="reference internal" href="#subnets">Subnets</a></li>
<li><a class="reference internal" href="#feature-finding-the-best-advice">Feature-finding: The best advice</a></li>
<li><a class="reference internal" href="#feature-finding-the-details">Feature-finding: The details</a></li>
<li><a class="reference internal" href="#prediction">Prediction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-trackpy-s-acceleration-features">Using trackpy&#8217;s acceleration features</a><ul>
<li><a class="reference internal" href="#theoretical-performance-diagnostics-performance-report">Theoretical performance diagnostics: <code class="docutils literal"><span class="pre">performance_report()</span></code></a></li>
<li><a class="reference internal" href="#numba"><code class="docutils literal"><span class="pre">numba</span></code></a></li>
<li><a class="reference internal" href="#pyfftw"><code class="docutils literal"><span class="pre">pyfftw</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-topics">Advanced topics</a><ul>
<li><a class="reference internal" href="#neighbor-finding-strategy-kdtree">Neighbor-finding strategy: KDTree</a></li>
<li><a class="reference internal" href="#empirical-performance-diagnostics-timing-and-profiling">Empirical performance diagnostics: Timing and profiling</a></li>
<li><a class="reference internal" href="#setup">Setup</a></li>
<li><a class="reference internal" href="#timing">Timing</a></li>
<li><a class="reference internal" href="#profiling">Profiling</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      
  <div class="section" id="making-trackpy-fast-er">
<h1>Making trackpy fast(er)<a class="headerlink" href="#making-trackpy-fast-er" title="Permalink to this headline">¶</a></h1>
<p>This notebook explains specific features built into <code class="docutils literal"><span class="pre">trackpy</span></code> to boost
performance, and it also provides some general suggestions on how to
make your particle tracking run faster.</p>
<p>First, set up matplotlib...</p>
<div class="code python highlight-python"><div class="highlight"><pre>%matplotlib inline
import matplotlib
from matplotlib.pyplot import imshow
</pre></div>
</div>
<p>Let&#8217;s check the <code class="docutils literal"><span class="pre">trackpy</span></code> version. If it&#8217;s not 0.2.0 or greater, the
following may not work.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">trackpy</span>
<span class="n">trackpy</span><span class="o">.</span><span class="n">__version__</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&#39;0.2.3-36-g98bb92c&#39;</span>
</pre></div>
</div>
<div class="section" id="general-advice">
<h2>General advice<a class="headerlink" href="#general-advice" title="Permalink to this headline">¶</a></h2>
<div class="section" id="subnets">
<h3>Subnets<a class="headerlink" href="#subnets" title="Permalink to this headline">¶</a></h3>
<p>As we&#8217;ll see in the examples below, the need to resolve &#8220;subnetworks&#8221; —
in which multiple neighboring particles in one frame could correspond to
multiple particles in the next — can drastically slow down tracking.
Subnets can be mitigated by reducing the <code class="docutils literal"><span class="pre">search_range</span></code> parameter in
the linking step, though this may result in more particles that cannot
be tracked. In the text below, we&#8217;ll look at some methods for finding
out just how much a of a problem subnets are.</p>
</div>
<div class="section" id="feature-finding-the-best-advice">
<h3>Feature-finding: The best advice<a class="headerlink" href="#feature-finding-the-best-advice" title="Permalink to this headline">¶</a></h3>
<p>Judicious use of the <code class="docutils literal"><span class="pre">minmass</span></code> and/or <code class="docutils literal"><span class="pre">threshold</span></code> parameters during
feature-finding, as described in the &#8220;walkthrough&#8221; tutorial notebook,
can considerably speed up feature-finding, linking, and analysis of
tracks. The best way to speed up a computation is usually to avoid doing
it at all.</p>
</div>
<div class="section" id="feature-finding-the-details">
<h3>Feature-finding: The details<a class="headerlink" href="#feature-finding-the-details" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">locate()</span></code> and <code class="docutils literal"><span class="pre">batch()</span></code> functions for feature-finding can use
either of two engines for their work, as specified by the optional
<code class="docutils literal"><span class="pre">engine</span></code> parameter:</p>
<ul class="simple">
<li>The <code class="docutils literal"><span class="pre">numba</span></code> engine is reasonably fast. It is the default when numba
is installed (see above).</li>
<li>The <code class="docutils literal"><span class="pre">python</span></code> engine is currently slightly more accurate, but
considerably slower.</li>
</ul>
<p>In addition, both engines do some extra work that you might not always
need:</p>
<ul class="simple">
<li>They iteratively try to refine the position of the feature centroid,
for the best possible subpixel accuracy. This can be turned off with
the parameter <code class="docutils literal"><span class="pre">max_iterations=0</span></code>.</li>
<li>They compute extra data about the feature, such as its eccentricity.
This can be turned off with <code class="docutils literal"><span class="pre">characterize=False</span></code>.</li>
</ul>
<p><strong>Note:</strong> Before sacrificing accuracy for performance, it&#8217;s best to know
objectively how much performance you are gaining. Read on to the
Advanced Topics section for information about how to time
feature-finding.</p>
</div>
<div class="section" id="prediction">
<h3>Prediction<a class="headerlink" href="#prediction" title="Permalink to this headline">¶</a></h3>
<p>As discussed in the &#8220;prediction&#8221; tutorial, for some data it is possible
to have your cake and eat it too: reduce <code class="docutils literal"><span class="pre">search_radius</span></code> to avoid
subnets, but still successfully track as many particles as possible.</p>
</div>
</div>
<div class="section" id="using-trackpy-s-acceleration-features">
<h2>Using trackpy&#8217;s acceleration features<a class="headerlink" href="#using-trackpy-s-acceleration-features" title="Permalink to this headline">¶</a></h2>
<p>For many kinds of data, <code class="docutils literal"><span class="pre">trackpy</span></code> spends most of its computing time in
just a handful of algorithms. Improving the performance of just these
few bottlenecks can dramatically speed up the entire code. <code class="docutils literal"><span class="pre">trackpy</span></code>
contains faster implementations of some of these algorithms, but they
are optional because they depend on other software that may not be
trivial to install. Making sure these components are happy can
dramatically speed up <code class="docutils literal"><span class="pre">trackpy</span></code>.</p>
<div class="section" id="theoretical-performance-diagnostics-performance-report">
<h3>Theoretical performance diagnostics: <code class="docutils literal"><span class="pre">performance_report()</span></code><a class="headerlink" href="#theoretical-performance-diagnostics-performance-report" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">trackpy</span></code> provides an easy way to see which of these speedups are in
effect.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">trackpy.diag</span>
<span class="n">trackpy</span><span class="o">.</span><span class="n">diag</span><span class="o">.</span><span class="n">performance_report</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Yes, but could it be faster?
FAST: numba is available and enabled (fast subnets and feature-finding).
FAST: Using pyfftw for image preprocessing.
</pre></div>
</div>
<p>Let&#8217;s look at each of these items in turn.</p>
</div>
<div class="section" id="numba">
<h3><code class="docutils literal"><span class="pre">numba</span></code><a class="headerlink" href="#numba" title="Permalink to this headline">¶</a></h3>
<p>2 algorithms in <code class="docutils literal"><span class="pre">trackpy</span></code> can be sped up by the
<code class="docutils literal"><span class="pre">`numba</span></code> &lt;<a class="reference external" href="http://numba.pydata.org">http://numba.pydata.org</a>&gt;`__ array-based just-in-time
compiler for Python:</p>
<ul class="simple">
<li>Iteratively refining the centroids of features, for better subpixel
resolution.</li>
<li>Resolving subnetworks, as part of the linking process.</li>
</ul>
<p>The source code actually contains separate Python and numba versions of
each. The default setting is to use the numba version when possible, but
to fall back on the Python version if numba is unavailable. You can also
control these choices manually, using the <code class="docutils literal"><span class="pre">engine</span></code> argument to
<code class="docutils literal"><span class="pre">locate()</span></code>, and the <code class="docutils literal"><span class="pre">link_strategy</span></code> argument when linking.</p>
<p>If you don&#8217;t have <code class="docutils literal"><span class="pre">numba</span></code>, we recommend using the Anaconda or Canopy
scientific Python distributions, which include <code class="docutils literal"><span class="pre">numba</span></code> and many other
useful packages.</p>
</div>
<div class="section" id="pyfftw">
<h3><code class="docutils literal"><span class="pre">pyfftw</span></code><a class="headerlink" href="#pyfftw" title="Permalink to this headline">¶</a></h3>
<p>The bandpass filtering that prepares an image for feature-finding is
done using fast Fourier transforms (FFT). The FFTW library is an
exceptionally fast implementation of FFT, and <code class="docutils literal"><span class="pre">pyfftw</span></code> is the module
that lets Python programs use it. Like numba, it optional, but it can
speed up the bandpass operation by a factor of ~3.</p>
<p>You should be able to install FFTW from your Linux package manager, or
on the Mac using <a class="reference external" href="http://brew.sh">Homebrew</a> (with the command
<code class="docutils literal"><span class="pre">brew</span> <span class="pre">install</span> <span class="pre">fftw</span></code>). Once you&#8217;ve done that, <code class="docutils literal"><span class="pre">pyfftw</span></code> itself should
install with <code class="docutils literal"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">pyfftw</span></code></p>
</div>
</div>
<div class="section" id="advanced-topics">
<h2>Advanced topics<a class="headerlink" href="#advanced-topics" title="Permalink to this headline">¶</a></h2>
<div class="section" id="neighbor-finding-strategy-kdtree">
<h3>Neighbor-finding strategy: KDTree<a class="headerlink" href="#neighbor-finding-strategy-kdtree" title="Permalink to this headline">¶</a></h3>
<p>An important operation in tracking (i.e. linking) is finding all the
particles that are close to a certain point in space. <code class="docutils literal"><span class="pre">trackpy</span></code> has
two ways of doing this</p>
<ul class="simple">
<li>A KDTree, which only handles more standard cases (e.g. Euclidean
geometries) and is written in C. (This is the default.)</li>
<li>A BTree hash, which is very flexible but written in pure Python and
tends to be slower.</li>
</ul>
<p>The method is set by the <code class="docutils literal"><span class="pre">neighbor_strategy</span></code> argument to the various
linking functions, which again defaults to KDTree. The KDTree is a
standard part of <code class="docutils literal"><span class="pre">scipy</span></code>; if you can run <code class="docutils literal"><span class="pre">trackpy</span></code> at all, it is
enabled.</p>
</div>
<div class="section" id="empirical-performance-diagnostics-timing-and-profiling">
<h3>Empirical performance diagnostics: Timing and profiling<a class="headerlink" href="#empirical-performance-diagnostics-timing-and-profiling" title="Permalink to this headline">¶</a></h3>
<p>What follows is a crash course in how to evaluate the performance of
tracking. The general suggestions given above are good starting points,
but they are just that — general suggestions. For your <em>specific</em>
application, you need <em>specific</em> data about how long the computation
takes, and how the computer is spending its time. This information may
help you make your own adjustments to your tracking method, or it may
help you when asking the <code class="docutils literal"><span class="pre">trackpy</span></code> developers for assistance (chances
are we&#8217;ll be happy to help!).</p>
<p>You will use these techniques with your own data, but let&#8217;s use the data
from the &#8220;walkthrough&#8221; tutorial.</p>
</div>
<div class="section" id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">trackpy</span> <span class="kn">as</span> <span class="nn">tp</span>
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">gray</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>

<span class="n">frames</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">ImageSequence</span><span class="p">(</span><span class="s">&#39;../sample_data/bulk_water/*.png&#39;</span><span class="p">,</span> <span class="n">process_func</span><span class="o">=</span><span class="n">gray</span><span class="p">)</span>
</pre></div>
</div>
<p>The speed at which we can read images from disk is not something we can
hope to improve much, so let&#8217;s get that out of the way before we do our
tests. Also, we don&#8217;t need to use all the frames for this example
(though you&#8217;re welcome to).</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># This gets the image data out of the pims ImageSequence object, and into a good old list in memory.</span>
<span class="n">frames_preload</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">frames</span><span class="p">[:</span><span class="mi">50</span><span class="p">])</span>
</pre></div>
</div>
<p>Just so we don&#8217;t forget what these images look like:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">imshow</span><span class="p">(</span><span class="n">frames_preload</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmap</span><span class="o">=</span><span class="n">matplotlib</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>&lt;matplotlib.image.AxesImage at 0x11c4fdc90&gt;
</pre></div>
</div>
<img alt="../_images/performance_18_1.png" src="../_images/performance_18_1.png" />
<p>Before we identify features, we need to give <code class="docutils literal"><span class="pre">trackpy</span></code> a chance to
&#8220;warm up&#8221; — initialize <code class="docutils literal"><span class="pre">fftw</span></code> and compile certain functions, if it
hasn&#8217;t done so already. So we&#8217;ll find features in just 2 frames:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="n">f2</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">frames_preload</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="mi">11</span><span class="p">,</span> <span class="n">minmass</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 2: 432 features
</pre></div>
</div>
</div>
<div class="section" id="timing">
<h3>Timing<a class="headerlink" href="#timing" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s find out — precisely — how long it takes to find features in a
single frame. You&#8217;ll notice that the following cell begins with the line
<code class="docutils literal"><span class="pre">%%timeit</span></code>. This is an example of a <em>cell magic</em>, which gives IPython
special instructions about how to run the rest of the cell.</p>
<div class="code python highlight-python"><div class="highlight"><pre>%%timeit
f1 = tp.batch(frames_preload[:1], 11, minmass=2000, invert=True)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 0: 438 features
1 loops, best of 3: 365 ms per loop
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">%%timeit</span></code> runs the same code multiple times and returns a somewhat
accurate measurement of execution time. We can use it to see how much
faster we can find features in this image when we turn off centroid
refinement and feature characterization:</p>
<div class="code python highlight-python"><div class="highlight"><pre>%%timeit
f1 = tp.batch(frames_preload[:1], 11, minmass=2000, invert=True,
              max_iterations=0, characterize=False)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 0: 435 features
1 loops, best of 3: 243 ms per loop
</pre></div>
</div>
<p>One thing to note is that the ratio of features to pixels is rather low
in this image. If you were finding features in a dense packing of
particles, the timing difference could be much more significant.</p>
</div>
<div class="section" id="profiling">
<h3>Profiling<a class="headerlink" href="#profiling" title="Permalink to this headline">¶</a></h3>
<p>Next, we&#8217;ll try to get a sense of what&#8217;s taking so long. The <code class="docutils literal"><span class="pre">%%prun</span></code>
cell magic instructs IPython to run the rest of the cell&#8217;s code using a
<em>profiler</em>.</p>
<div class="code python highlight-python"><div class="highlight"><pre>%%prun
f = tp.batch(frames_preload, 11, minmass=2000, invert=True)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 49: 442 features
</pre></div>
</div>
<p>When execution is complete, a pager will pop up in the lower portion of
the notebook window. This is the profiler output. We reproduce a portion
of it here. Your results will depend on your data and the computer you
are using.</p>
<div class="highlight-python"><div class="highlight"><pre>721076 function calls (719979 primitive calls) in 14.295 seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    50    3.949    0.079    3.949    0.079 {scipy.ndimage._nd_image.min_or_max_filter}
   200    2.855    0.014    3.006    0.015 _utils.py:29(_Xfftn)
    50    0.917    0.018    0.917    0.018 {scipy.ndimage._nd_image.binary_erosion}
   150    0.828    0.006    0.828    0.006 {numpy.core.multiarray.where}
    50    0.741    0.015    6.211    0.124 feature.py:21(local_maxima)
   200    0.670    0.003    0.670    0.003 {scipy.ndimage._nd_image.uniform_filter1d}
 24345    0.621    0.000    1.098    0.000 feature.py:71(estimate_mass)
 53750    0.555    0.000    0.556    0.000 {method &#39;reduce&#39; of &#39;numpy.ufunc&#39; objects}
 27957    0.383    0.000    0.820    0.000 _methods.py:49(_mean)
   100    0.282    0.003    5.185    0.052 preprocessing.py:34(bandpass)
   100    0.271    0.003    0.271    0.003 {scipy.ndimage._nd_image.fourier_filter}
    50    0.191    0.004   14.152    0.283 feature.py:400(locate)
    50    0.176    0.004    0.176    0.004 {method &#39;sort&#39; of &#39;numpy.ndarray&#39; objects}
   100    0.174    0.002    0.174    0.002 {method &#39;nonzero&#39; of &#39;numpy.ndarray&#39; objects}
   151    0.108    0.001    0.108    0.001 {method &#39;query_pairs&#39; of &#39;scipy.spatial.ckdtree.cKDTree&#39; objects}
</pre></div>
</div>
<p>This is a record of how the computer spent its time while finding
features. The various numbers are explained in the <cite>documentation for
the Python ``profiler`</cite>
module &lt;<a class="reference external" href="http://docs.python.org/2/library/profile.html#instant-user-s-manual">http://docs.python.org/2/library/profile.html#instant-user-s-manual</a>&gt;`__.
You shouldn&#8217;t try to understand every line, but you can get some idea of
which functions are called for each frame (multiples of 50), and which
are called for each particle. Note that <code class="docutils literal"><span class="pre">{functions</span> <span class="pre">in</span> <span class="pre">braces}</span></code> are
written in C, not Python, are not part of <code class="docutils literal"><span class="pre">trackpy</span></code>, and tend to be
less user-serviceable.</p>
<p>Now let&#8217;s look at the linking step. Once again, we&#8217;ll prime <code class="docutils literal"><span class="pre">trackpy</span></code>,
to avoid distorting our results with one-time setup code:</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="c"># Use a large search_range, to be sure that numba subnet code is compiled and used.</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">tp</span><span class="o">.</span><span class="n">link_df</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">memory</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 2: 432 trajectories present
</pre></div>
</div>
<div class="code python highlight-python"><div class="highlight"><pre>%%prun
t = tp.link_df(f, 5, memory=3)
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>Frame 49: 442 trajectories present
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre>1379151 function calls (1378749 primitive calls) in 2.557 seconds

Ordered by: internal time

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
    51    0.209    0.004    2.129    0.042 linking.py:614(link_iter)
 19596    0.207    0.000    0.927    0.000 series.py:126(__init__)
 19443    0.122    0.000    0.253    0.000 series.py:2490(_sanitize_array)
248849    0.109    0.000    0.114    0.000 {isinstance}
   400    0.108    0.000    1.399    0.003 {map}
   539    0.093    0.000    0.114    0.000 linking.py:1062(numba_link)
 41310    0.092    0.000    0.093    0.000 {numpy.core.multiarray.array}
 19646    0.088    0.000    0.267    0.000 internals.py:3571(__init__)
 19091    0.074    0.000    0.949    0.000 frame.py:507(iterrows)
 19902    0.071    0.000    0.153    0.000 internals.py:1944(make_block)
 19041    0.065    0.000    0.310    0.000 linking.py:598(&lt;lambda&gt;)
    49    0.063    0.001    0.170    0.003 linking.py:871(assign_candidates)
</pre></div>
</div>
<p>This goes much faster than feature identification, though to be fair, we
have far, far more pixels than particles. Note the calls to
<code class="docutils literal"><span class="pre">numba_link</span></code>; this is the subnet resolution code referred to above. If
you require a large <code class="docutils literal"><span class="pre">search_range</span></code>, these computations can
dramatically slow down linking. As it is, they are under control.</p>
<p>Well, I hope you&#8217;ve enjoyed this brief tour of <code class="docutils literal"><span class="pre">trackpy</span></code> performance.
Just remember that if you come up with new ways to improve performance,
the <code class="docutils literal"><span class="pre">trackpy</span></code> community will be very interested!</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
<div id="sourcelink">
  <a href="../_sources/tutorial/performance.txt"
     rel="nofollow">Source</a>
</div>
      
    </p>
    <p>
        &copy; Copyright 2010-2014, Trackpy Contributors.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>